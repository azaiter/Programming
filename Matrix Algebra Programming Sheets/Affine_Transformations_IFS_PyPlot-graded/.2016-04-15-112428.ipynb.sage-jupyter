{"kernelspec":{"display_name":"Julia","language":"julia","name":"julia-0.4"},"language_info":{"file_extension":".jl","mimetype":"application/julia","name":"julia","version":"0.4.1"}}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# Affine Transformations and Iterated Function Systems"}
{"cell_type":"markdown","metadata":{},"source":"This homework is on some of the material in section 6.2."}
{"cell_type":"markdown","metadata":{},"source":"## Affine transformations"}
{"cell_type":"markdown","metadata":{},"source":"We have already experimented several times with using matrices to encode geometric transformations of points and other objects in the plane $\\mathbb{R}^2$.  One thing that all the transformations we explored so far had in common was that they were all done by _multiplying points (vectors) in the plane by a matrix_. That means they all were _linear transformations_.  One consequence was that all of the transformations we studied _mapped the origin on the origin_, since the image of the zero vector under a linear transformation is always a zero vector.\n\nThat means we were somewhat limited in what transformations we can use: we could do scaling, scaling by a different factor in $x$ and $y$ direction, shear, reflection over a subspace, rotation around the origin, and projection to a subspace.  Some of the things we could not do were _shifting_ (a.k.a. _translation_) and _rotation around an arbitrary point_.\n\nIn order to be able to include these geometric transformations, we need to extend the set of vector transformations we use to so called __affine transformations__.\nAn _affine transformation_ is simply a linear transformation followed by a shift. In order to describe an affine transformation, we need a square matrix $A$ that will represent the linear transformation, and a vector $\\mathbf{b}$ that will represent the shift.  So an affine transformation can be written as\n\n$$T\\mathbf{x} = A\\mathbf{x} + \\mathbf{b}$$"}
{"cell_type":"markdown","metadata":{},"source":"### An example\n\nLet's look at the effect of the transformation given by \n\n$$T\\mathbf{x} = \\begin{bmatrix}2 & 1\\\\-1 &1\\end{bmatrix}\\mathbf{x} + \\begin{bmatrix}1\\\\2\\end{bmatrix}$$"}
{"cell_type":"markdown","metadata":{},"source":"To be able to see the effect, we will want  to plot it.  In the past we used the JSXGraph package for plotting out transformation, however, that package is not powerful and fast enough to be used in the second part of this homework.  We will use a much more powerful `PyPlot` package.  To load the package and set it up, we do"}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"using PyPlot\nion() #turn on the \"interactive\" mode so the plots will actually display"}
{"cell_type":"markdown","metadata":{},"source":"Now we will define the function that will do the transformation:"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"T (generic function with 1 method)"},"execution_count":2,"metadata":{},"output_type":"execute_result"}],"source":"function T(x)\n    return [2 1; -1 1]*x + [1;2]\nend"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"2-element Array{Int64,1}:\n 5\n 3"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"T([1,2])"}
{"cell_type":"markdown","metadata":{},"source":"We see that the affine transformation $T$ maps the point $(1,2)$ to the point $(5,3)$. When we studied linear transformations in the plane, we usually \ntransformed whole bunch of points at once simply by writing the points as columns of a matrix and multiplying this matrix by the transformation matrix. \n\nThat will not work here.  Trying to apply an affine transformation to a matrix will cause an error.  The matrix multiplication will work fine, but the vector addition will not, since we will by trying to add matrices with different number of columns, which is impossible.  Luckily there is a way around this: the `mapslices` function lets us apply a function on all columns (or all rows) of a matrix. (We will see below that there is a better way to do this.)\n\n----"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"search: "},{"data":{"text/latex":"smc-blob::9ba17682-0a92-4155-b2c7-5ee43cde9648","text/markdown":"```\nmapslices(f, A, dims)\n```\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice of `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]` for all `i` and `j`.\n","text/plain":"```\nmapslices(f, A, dims)\n```\n\nTransform the given dimensions of array `A` using function `f`. `f` is called on each slice of `A` of the form `A[...,:,...,:,...]`. `dims` is an integer vector specifying where the colons go in this expression. The results are concatenated along the remaining dimensions. For example, if `dims` is `[1,2]` and `A` is 4-dimensional, `f` is called on `A[:,:,i,j]` for all `i` and `j`.\n"},"execution_count":9,"metadata":{},"output_type":"execute_result"},{"name":"stdout","output_type":"stream","text":"mapslices\n\n"}],"source":"?mapslices"}
{"cell_type":"markdown","metadata":{},"source":"----\nWe want to iterate over the columns, which means that the first dimension, the number of row, is going to be unspecified and replaced by a colon.\n\nTo apply the transformation $T$ on the points $(1,2)$, $(2,1)$ and $(3,4)$, we apply `mapslices` to the matrix\n\n$$\\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 1 & 4\\end{bmatrix}$$"}
{"cell_type":"code","execution_count":10,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"2x3 Array{Int64,2}:\n 5  6  11\n 3  1   3"},"execution_count":10,"metadata":{},"output_type":"execute_result"}],"source":"mapslices(T, [1 2; 2 1; 3 4]', 1)"}
{"cell_type":"markdown","metadata":{},"source":"### Transforming a square\n\nIn the previous homework on transformations in the plane, we always transformed the square given by the points $(0,0)$, $(1,0)$, $(1,1)$ and $(0,1)$, so we will do the same now:"}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"2x4 Array{Int64,2}:\n 0  1  1  0\n 0  0  1  1"},"execution_count":11,"metadata":{},"output_type":"execute_result"}],"source":"square = [0 0; 1 0; 1 1; 0 1]'"}
{"cell_type":"markdown","metadata":{},"source":"The transformed image of the square will be:"}
{"cell_type":"code","execution_count":13,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"2x4 Array{Int64,2}:\n 1  3  4  2\n 2  1  2  3"},"execution_count":13,"metadata":{},"output_type":"execute_result"}],"source":"transformed = mapslices(T, square, 1)"}
{"cell_type":"markdown","metadata":{},"source":"To plot polygons, we will use the `fill` method of `PyPlot`.  It takes arguments in multiples of three: first is the $x$-coordinates of the polygon vertices, then the $y$-coordinates, then a string describing plotting style.  If you need to plot more than one polygon, you provide three more arguments: $x$-coordinates of the second polygon, $y$-coordinates of the second polygon, the style of the second polygon, _e.t.c._ \n\nWe will plot the square in red, denoted by `\"r\"`, and the transformed shape in blue, `\"b\"`.  \n\nTo extract the $x$ and $y$-coordinates, we need to extract the first row (`square[1,:]`) and the second row (`square[2,:]`)."}
{"cell_type":"code","execution_count":16,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::0c50d5eb-e83d-4763-93fd-9caa5961084e","text/plain":"PyPlot.Figure(PyObject <matplotlib.figure.Figure object at 0x7f65b7567b10>)"},"metadata":{},"output_type":"display_data"},{"data":{"text/plain":"2-element Array{Any,1}:\n PyObject <matplotlib.patches.Polygon object at 0x7f65b75ed5d0>\n PyObject <matplotlib.patches.Polygon object at 0x7f65b7597f90>"},"execution_count":16,"metadata":{},"output_type":"execute_result"}],"source":"fill(square[1,:]', square[2,:]', \"r\", transformed[1,:]', transformed[2,:]', \"b\")"}
{"cell_type":"markdown","metadata":{},"source":"You can see that the transformed polygon does not have the origin as one of its corners."}
{"cell_type":"markdown","metadata":{},"source":"## Homogeneous coordinates"}
{"cell_type":"markdown","metadata":{},"source":"We saw that applying an affine transformation to a large number of points is somewhat cumbersome, since we had to iterate over the column of the point matrix\nusing `mapslices`.  Linear transformations are much easier, all you have to do is just a matrix multiplication. \n\nThere is actually a way to do affine transformations by simple matrix multiplication.  One has to introduce so called _homogeneous coordinates_. The idea is to represent points by vectors in $\\mathbb{R}^3$ instead of $\\mathbb{R}^2$, with the third component __always being 1__.  For example the point $(3,4)$ would be represented by \n\n$$\\begin{bmatrix}3\\\\4\\\\1\\end{bmatrix}$$"}
{"cell_type":"markdown","metadata":{},"source":"An affine transformation \n\n$$T\\mathbf{x} = A\\mathbf{x} + \\mathbf{b}$$\n\nwill then be represented by the matrix\n\n$$\\begin{bmatrix} a_{11} & a_{12} & b_1 \\\\ a_{21} & a_{22} & b_2 \\\\ 0 & 0 & 1\\end{bmatrix}$$"}
{"cell_type":"markdown","metadata":{},"source":"The set of all affine coordinates of points in the plane does not form a vector space, and the origin is not actually represented by the zero vector, and so affine transformation can be represented by matrix multiplication even though they do not always map the origin to the origin."}
{"cell_type":"markdown","metadata":{},"source":"As an example, let's look at the affine transformation we were looking at above:\n\n$$T\\mathbf{x} = \\begin{bmatrix}2 & 1\\\\-1 &1\\end{bmatrix}\\mathbf{x} + \\begin{bmatrix}1\\\\2\\end{bmatrix}$$\n\nThis will be represented by the matrix\n\n$$\\begin{bmatrix}2 & 1 & 1\\\\ -1 & 1 & 2\\\\ 0 & 0 & 1\\end{bmatrix}$$"}
{"cell_type":"code","execution_count":18,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"3x3 Array{Int64,2}:\n  2  1  1\n -1  1  2\n  0  0  1"},"execution_count":18,"metadata":{},"output_type":"execute_result"}],"source":"A = [2 1 1; -1 1 2; 0 0 1]"}
{"cell_type":"markdown","metadata":{},"source":"The points $(1,2)$, $(2,1)$ and $(3,4)$ will be, in _homogeneous coordinates_, represented by the matrix\n\n$$\\begin{bmatrix} 1 & 2 & 3\\\\ 2 & 1 & 4\\\\1 & 1 & 1\\end{bmatrix}$$"}
{"cell_type":"code","execution_count":21,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"3x3 Array{Int64,2}:\n 1  2  3\n 2  1  4\n 1  1  1"},"execution_count":21,"metadata":{},"output_type":"execute_result"}],"source":"points = vcat([1 2; 2 1; 3 4]', [1 1 1])"}
{"cell_type":"markdown","metadata":{},"source":"The affine transformation will simply be a matrix multiplication:"}
{"cell_type":"code","execution_count":22,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"3x3 Array{Int64,2}:\n 5  6  11\n 3  1   3\n 1  1   1"},"execution_count":22,"metadata":{},"output_type":"execute_result"}],"source":"A*points"}
{"cell_type":"markdown","metadata":{},"source":"Ignoring the third row, we see that these are the same three points as we have obtained earlier.\n\nWe will now regenerate the plot we made above, this time using homogeneous coordinates and matrix multiplication:"}
{"cell_type":"code","execution_count":29,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"3x4 Array{Int64,2}:\n 0  1  1  0\n 0  0  1  1\n 1  1  1  1"},"execution_count":29,"metadata":{},"output_type":"execute_result"}],"source":"square_h = vcat(square, fill(1,4)')"}
{"cell_type":"code","execution_count":26,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"3x4 Array{Int64,2}:\n 1  3  4  2\n 2  1  2  3\n 1  1  1  1"},"execution_count":26,"metadata":{},"output_type":"execute_result"}],"source":"transformed_h = A*square_h"}
{"cell_type":"code","execution_count":27,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::0c50d5eb-e83d-4763-93fd-9caa5961084e","text/plain":"PyPlot.Figure(PyObject <matplotlib.figure.Figure object at 0x7f65b7619fd0>)"},"metadata":{},"output_type":"display_data"},{"data":{"text/plain":"2-element Array{Any,1}:\n PyObject <matplotlib.patches.Polygon object at 0x7f65b3a5da90>\n PyObject <matplotlib.patches.Polygon object at 0x7f65b3a5dd90>"},"execution_count":27,"metadata":{},"output_type":"execute_result"}],"source":"fill(square_h[1,:]', square_h[2,:]', \"r\", transformed_h[1,:]', transformed_h[2,:]', \"b\")"}
{"cell_type":"markdown","metadata":{},"source":"## Homework part 1\n\nRead the subsection \"Transformations in computer graphics\" on page 279 and the example on pages 280 and 281.  Then construct a matrix representation of the \nrotation by $30^\\circ$ counterclockwise around the point $(1.2, 1.4)$.  Find the matrix by __first creating the three invidual transformation matrices__ (translation, rotation, and the second translation) __and multiplying the matrices in Julia__, rather than plugging numbers into the formula at the bottom of page 280.  Use the empy cell below to enter your code.  If you need more than one cell, pressing <Alt>-<Enter> instead of <Shift>-<Enter> will create additional cells for you.  For bonus points, transform a small triangle, and plot the original triangle and its transformed image on the same plot."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}
{"cell_type":"markdown","metadata":{},"source":"## Iterated Function Systems"}
{"cell_type":"markdown","metadata":{},"source":"In the second part of the homework, you will use _affine transformations_ and _homogeneous coordinates_ to plot some iterated function systems, as described in the subsection \"Fractal Pictures of Nature\" on pages 281-283.  You can start by reading the subsection, if you have not done so already."}
{"cell_type":"markdown","metadata":{},"source":"As an example, I will implement the iterated function system that is described in the book.  You will then use the framework that I set up to experiment with other iterated function systems.\n\nEach iterated function system consists of several affine transformations.  Usually, each transformation also has a probability associated with it.  Sometimes there are no probabilities specified, which means that all the probabilities are equal. The process if generating the IFS plot is described on page 282.  It basically boils down to repeatedly randomly choosing one of the transformations according to the probabilities and applying it to the point that was the result of the previous step."}
{"cell_type":"markdown","metadata":{},"source":"### Setup:\n\nIn the setup part, we will create a list of affine transformation matrices.  We will also need a way to randomly choose one of them with given probabilities."}
{"cell_type":"markdown","metadata":{},"source":"#### Create the affine matrices"}
{"cell_type":"markdown","metadata":{},"source":"Since we will be dealing with whole bunch of affine transformations, it may be a good idea to automate the process of creation of affine matrices.  We will write a function that will receive a $2\\times 2$ matrix and a vector from $\\mathbb{R}^2$ and turn it into an affine transformation matrix by stacking them together and appending `[0 0 1]` as the third row:"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"affine (generic function with 1 method)"},"execution_count":1,"metadata":{},"output_type":"execute_result"}],"source":"function affine(A, b)\n    return vcat(hcat(A, b), [0 0 1])\nend"}
{"cell_type":"markdown","metadata":{},"source":"Test it of the transformation that we used above:"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"3x3 Array{Int64,2}:\n  2  1  1\n -1  1  2\n  0  0  1"},"execution_count":2,"metadata":{},"output_type":"execute_result"}],"source":"affine([2 1; -1 1], [1,2])"}
{"cell_type":"markdown","metadata":{},"source":"#### Generate random integers\nWe will also need a way to generate random integers with given probabilities.  An easy way to do this is to create a coroutine that produces the integers for us, and then just keep calling the coroutine when we need the integers.  The function will receive a list of probabilities, the first of which will be the prbability of 1, second will be the probability of 2, theird probability of 3, _e.t.c._  If $n$ probabilities are given and they add up to less than 1, the missing amount will be the probability of $n+1$.  If the probabilities add up to more than 1, the last few probabilities will be ignored.  There is also an optional argument `precision` with default value 2, which specify how many decimal places will the probabilities be rounded to:"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"produce_ints (generic function with 2 methods)"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"function produce_ints(probs, precision=2)\n    max = 10^precision;\n    boundaries = vcat(cumsum(round(max*probs)), [max+1])\n    while true\n        n = rand(1:max)\n        produce(findfirst(x -> x >= n, boundaries))\n    end\nend"}
{"cell_type":"markdown","metadata":{},"source":"_Side note:_ If you are curious about the \"2 methods\" that the function `produce_ints` seems to have, we can look at the methods this way:"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"2 methods for generic function <b>produce_ints</b>:<ul><li> produce_ints(probs) at In[3]:2<li> produce_ints(probs, precision) at In[3]:2</ul>","text/plain":"# 2 methods for generic function \"produce_ints\":\nproduce_ints(probs) at In[3]:2\nproduce_ints(probs, precision) at In[3]:2"},"execution_count":4,"metadata":{},"output_type":"execute_result"}],"source":"methods(produce_ints)"}
{"cell_type":"markdown","metadata":{},"source":"As we can see, the 2 methods are caused by the optional argument: there is one method for calling the function without the optinal argument, and one for calling it with the optional argument.  _End of side note._"}
{"cell_type":"markdown","metadata":{},"source":"To test our coroutine and to demonstrate how to use it, we will generate 10,000 integers 1 - 4 with given probabilities, and count how many of each were generated:"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"The integer 1 was generated 9.71% of time.\nThe integer 2 was generated 40.81% of time.\nThe integer 3 was generated 30.0% of time.\nThe integer 4 was generated 19.48% of time.\n"}],"source":"counts = fill(0, 4)\nprobs = [0.1, 0.4, 0.3, 0.2]\n\nfor (i, n) in enumerate(@task produce_ints(probs))\n    counts[n] += 1\n    if i == 10_000\n        break\n    end\nend\n\nfor (n,p) in enumerate(counts)\n    println(\"The integer $n was generated $(p/100)% of time.\")\nend"}
{"cell_type":"markdown","metadata":{},"source":"### The example\n\nNow that we have a way to easily create affine matrices and to generate random integers with given probabilities, we can go ahead and do an example of an iterated function system."}
{"cell_type":"markdown","metadata":{},"source":"First we will create a list of affine matrices, using the transformations listed on page 282:"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"(\n3x3 Array{Float64,2}:\n  0.86  0.03  0.0\n -0.03  0.86  1.5\n  0.0   0.0   1.0,\n\n3x3 Array{Float64,2}:\n 0.2   -0.25  0.0\n 0.21   0.23  1.5\n 0.0    0.0   1.0,\n\n3x3 Array{Float64,2}:\n -0.15  0.27  0.0 \n  0.25  0.26  0.45\n  0.0   0.0   1.0 ,\n\n3x3 Array{Float64,2}:\n 0.0  0.0   0.0\n 0.0  0.17  0.0\n 0.0  0.0   1.0)"},"execution_count":6,"metadata":{},"output_type":"execute_result"}],"source":"Transforms = (\naffine([.86 .03; -.03 .86], [0, 1.5]),\naffine([.2 -.25; .21 .23], [0, 1.5]),\naffine([-.15 .27; .25 .26], [0, .45]),\naffine([0 0; 0 .17], [0,0]),\n)"}
{"cell_type":"markdown","metadata":{},"source":"Then we will prepare the probabilities:"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"3-element Array{Float64,1}:\n 0.83\n 0.08\n 0.08"},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":"probs = [.83, .08, .08]"}
{"cell_type":"markdown","metadata":{},"source":"Notice that I did not include the last one, since it will be filled in automatically, and it will prevent accidentally generating 5 with some very small but nonzero probability due to a rounding error."}
{"cell_type":"markdown","metadata":{},"source":"We will generate 200,000 points:"}
{"cell_type":"code","execution_count":19,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"200000"},"execution_count":19,"metadata":{},"output_type":"execute_result"}],"source":"number_of_points = 200_000"}
{"cell_type":"markdown","metadata":{},"source":"Now we are ready to actually calculate the points of the iterated function system:"}
{"cell_type":"code","execution_count":20,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"3x200000 Array{Float64,2}:\n 0.0   0.0135  0.507465  0.46474  0.468575  â€¦  -1.50017  -1.16574  -0.849194\n 0.45  1.887   0.943995  2.29661  3.46114       4.14698   5.11141   5.93079 \n 1.0   1.0     1.0       1.0      1.0           1.0       1.0       1.0     "},"execution_count":20,"metadata":{},"output_type":"execute_result"}],"source":"points = Array{Float64}(3, number_of_points)  # reserve space for the points\n\npt = [0,0,1] # homogeneous coordinates of the origin\n\nfor (i, n) in enumerate(@task produce_ints(probs))\n    pt = Transforms[n]*pt\n    points[:,i] = copy(pt)\n    if i == number_of_points\n        break\n    end\nend\n\npoints"}
{"cell_type":"markdown","metadata":{},"source":"Now the variable `points` contains the homogeneous coordinates of 200,000 points that approximate the resulting fractal.  We will now plot the points.\n\n<span style=\"color:red; font-size:120%\">__Important:__ Make sure you transpose the $x$ and $y$ coordinates before plugging them into `plot`.  It expects the coordinates to be in a column matrix or a vector, and when it receives a large row matrix, it __hangs for ever and is really hard to kill!__</span>.  If you accidentally plug in a large row matrix to `plot` and it hangs, first try to interrupt the kernel using the little black square button on the toolbar, and if that does not work, go to the settings tab (the one with the wrench) and restart the project.  You may have to refrest the notebook afterwards.  That's what the `'` in the `xs = points[1,:]'` is for!"}
{"cell_type":"code","execution_count":27,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"image/png":"smc-blob::a657515a-b014-4efa-9acb-99a8996c9632","text/plain":"PyPlot.Figure(PyObject <matplotlib.figure.Figure object at 0x7f0a106a8d10>)"},"metadata":{},"output_type":"display_data"},{"data":{"text/plain":"1-element Array{Any,1}:\n PyObject <matplotlib.lines.Line2D object at 0x7f0a105ea4d0>"},"execution_count":27,"metadata":{},"output_type":"execute_result"}],"source":"xs = points[1,:]' # extract x coordinate and TRANSPOSE THEM!!!!!!!!!!\nys = points[2,:]' # extract y coordinate and TRANSPOSE THEM!!!!!!!!!!\n\nfigure(figsize=(5, 10))\nplot(xs, ys, \"g.\",  markersize=1)"}
{"cell_type":"markdown","metadata":{"collapsed":true,"trusted":false},"source":"## Homework part 2:\n\nIn the second part of this homework, you will experiment with iterated function systems, and produce another IFS plot, different from the one above.  You can tweak the parameters of the original system and see how the image reacts, you can study the theory of iterated function systems (you may want to search the _Collage  Theorem_) and design your own system from scratch, or you can find some recipes for iterated functions systems online (see for example the site http://ecademy.agnesscott.edu/~lriddle/ifs/ifs.htm).  You can use the functions defined above in your code, or you can create your own, it is up to you.  I will give bonus points for especially cool or original plots."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}